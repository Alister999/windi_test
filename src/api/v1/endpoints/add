async def get_recipient_ids(db: AsyncSession, chat_id: int, sender_id: int) -> Set[int]:
    group = await db.execute(select(Group).where(Group.id == chat_id))
    group = group.scalars().first()
    if not group:
        raise HTTPException(status_code=404, detail="Chat not found")
    return {user.id for user in group.users if user.id != sender_id}




logger.info(f"Connecting user {username} (id: {current_user.id}) to chat {chat_id}")
    if current_user.name != username:
        logger.error(f"Unauthorized user {username}, token user: {current_user.name}")
        await websocket.close(code=1008, reason="Unauthorized")
        return

    group_repo = GroupRepository(session=db)
    group = await group_repo.get_one_or_none(Group.id == chat_id)
    if not group or current_user.id not in {u.id for u in group.users}:
        logger.error(f"User {username} (id: {current_user.id}) not in chat {chat_id}")
        await websocket.close(code=1008, reason="User not in chat")
        return

    await manager.connect(websocket, chat_id, current_user.id)

    try:
        while True:
            try:
                data = await websocket.receive_json()
                message_type = data.get("type")
                logger.info(f"Received message type {message_type} from user {username} (id: {current_user.id}) in chat {chat_id}")

                if message_type == "message":
                    if not all(key in data for key in ["text", "client_message_id"]):
                        logger.warning(f"Missing fields in message from user {username}")
                        await websocket.send_json({"error": "Missing 'text' or 'client_message_id'"})
                        continue

                    message_data = MessageCreate(
                        chat_id=chat_id,
                        text=data["text"],
                        client_message_id=data["client_message_id"]
                    )

                    message_repo = MessageRepository(session=db)
                    existing_message = await message_repo.get_one_or_none(
                        Message.client_message_id == message_data.client_message_id
                    )
                    if existing_message:
                        logger.warning(f"Duplicate message {message_data.client_message_id} from user {username}")
                        await websocket.send_json({"warning": "Duplicate message ignored"})
                        continue

                    message = Message(
                        chat_id=message_data.chat_id,
                        sender_id=current_user.id,  # Используем current_user.id
                        text=message_data.text,
                        client_message_id=message_data.client_message_id
                    )

                    await message_repo.add(message)
                    await db.commit()
                    await db.refresh(message)
                    logger.info(f"Message saved: id={message.id}, text={message.text}")

                    response = MessageResponse.model_validate(message)
                    broadcast_message = {
                        "type": "message",
                        "message": response.dict()
                    }

                    recipient_ids = await get_recipient_ids(db, chat_id, current_user.id)
                    await manager.send_message(broadcast_message, chat_id, recipient_ids | {current_user.id})

                elif message_type == "read":
                    if "message_id" not in data:
                        logger.warning(f"Missing message_id from user {username}")
                        await websocket.send_json({"error": "Missing 'message_id'"})
                        continue

                    message_id = data["message_id"]
                    message_repo = MessageRepository(session=db)
                    message = await message_repo.get_one_or_none(Message.id == message_id)
                    if message and message.chat_id == chat_id and not message.is_read:
                        message.is_read = True
                        await db.commit()
                        logger.info(f"Message {message_id} marked as read by user {username}")
                        await manager.broadcast_read_status(chat_id, message_id, current_user.id)
                    else:
                        logger.warning(f"Invalid or already read message {message_id} from user {username}")
                        await websocket.send_json({"error": "Invalid or already read message"})

                else:
                    logger.warning(f"Unknown message type {message_type} from user {username}")
                    await websocket.send_json({"error": f"Unknown message type: {message_type}"})

            except json.JSONDecodeError as e:
                logger.error(f"Invalid JSON from user {username} in chat {chat_id}: {str(e)}")
                await websocket.send_json({"error": "Invalid JSON format"})
                continue

    except Exception as e:
        logger.error(f"WebSocket error for user {username} in chat {chat_id}: {str(e)}")
        manager.disconnect(websocket, chat_id, current_user.id)  # Убрано await
        await websocket.close(code=1000)





         #getLogger(__name__)